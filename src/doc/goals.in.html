<h2>Introduction</h2>

<a href="http://ecls.sourceforge.net">ECL</a> stands for <em>Embeddable
Common-Lisp "Spain"</em>, and I usually read it as "e-klos". It is a an
implementation of the <a href="http://www.lisp.org">Common-Lisp language</a>
which aims to comply to the <a
href="http://www.lisp.org/HyperSpec/FrontMatter/index.html">ANSI X3J13</a>
definition of the language.

<p><a href="http://ecls.sourceforge.net">ECL</a> combines a bytecodes
compiler/interpreter and a translator to C.  The first one is specially suited
for prototyping and debugging. The second one produces fast code that can be
dynamically loaded into the interpreter or statically linked to build
standalone executables.

<p><a href="http://ecls.sourceforge.net">ECL</a> is distributed under the <a
href="#copyright">GNU Library General Public License (GNU LGPL)</a>.

<h2>ECL vs other implementations</h2>

<p><a href="http://ecls.sourceforge.net">ECL</a> is not a brand new
product. It has evolved from the EcoLisp implementation by Giuseppe Attardi
which in turn was based on the Kyoto Common-Lisp implementation done by Taiichi
Yuasa and Masami Hagiya, with contributions from several people. Nevertheless
the program has been seriously modified and the current code base bears little
resemblance to the previous implementations and the author of those
implementations should not be blamed for the faults of <a
href="http://ecls.sourceforge.net">ECL</a>.

<p>I have received several questions concerning why I work on ECL
instead of improving GCL. The main reason for this is the simplicity
of the code base. The EcoLisp implementation on which ECL is based
already was Cltl2 compliant. It had low level support for CLOS, a LOOP
package, DEFPACKAGE and the code in general was much more readable and
easier to maintain. It would be a huge task to get all these
improvements back and the code I put into ECL back into GCL.</p>

<h2>Project goals</h2>

<ul>
<li><b>To produce a free implementation of Common-Lisp.</b>

<p><a href="http://ecls.sourceforge.net">ECL</a> is released under the LGPL or
GNU Library General Public Licence (See <a
href="license.html">Copyright</a>). This means that <a
href="http://ecls.sourceforge.net">ECL</a> can be used in commercial projects
while keeping the implementation free.

<li><b>Compliance to the latest ANSI spec.</b>

<p><a href="http://ecls.sourceforge.net">ECL</a> is already rather standards
compliant. <a href="http://ecls.sourceforge.net">ECL</a> was born as a fork
from the ECL (Eco-Common-Lisp by Giusepe Attardi) which conformed to Cltl2
("Common-Lisp the Language 2"), but which was shipped with some ANSI
compatibility extensions. Currently the worst parts with respect to ANSI are
the LOOP package and parts of CLOS.

<li><b>Small code size.</b>

<p><a href="http://ecls.sourceforge.net">ECL</a> is made of a runtime library
and an interpreter. The interpreter itself is small, at most three files of C
code. Once the lisp environment is booted, it takes about 1Mb of code (although
currently it is a bit more due to debuggin issues in the interpreter). If the
whole of <a href="http://ecls.sourceforge.net">ECL</a> is compiled from lisp
to C, the resulting program is 1.5Mb. Nevertheless, there is room for
improvement in this area.

<li><b>Embedability.</b>

<p><a href="http://ecls.sourceforge.net">ECL</a> is shipped as a
library that can be linked against arbitrary C programs. Arbitrary
C/C++ code can be linked against <a
href="http://ecls.sourceforge.net">ECL</a>, either statically or at
runtime.

<li><b>Portability to arbitrary environments.</b>

<p><a href="http://ecls.sourceforge.net">ECL</a> is currently supported in
<ul>
<li>Linux on Intel, PowerPC, Alpha and Opteron</li>
<li>FreeBSD on Intel</li>
<li>NetBSD on Intel and Alpha</li>
<li>Microsoft Windows</li>
<li>MacOSX (currently broken)</li>
</ul>
Most of the code is portable and clean from issues like endianness and
word size (<a href="http://ecls.sourceforge.net">ECL</a> works on 64
bit architectures). The parts which change from operating system to
operating system are about the filesystem, sockets, signals and the
allocation of big chunks of memory, but in all it is well below 1000
lines.

<li><b>Compilation via an ANSI C compiler.</b>

<p><a href="http://ecls.sourceforge.net">ECL</a> can translate lisp code to C
code that can be dynamically loaded or linked to the runtime to produce a
standalone executable. Currently this process relies on GCC as a target
platform, but work is in progress to remove GCC dependencies.

<li><b>Better garbage collection.</b>

<p>As of this release the ECL fully relies on the Boehm-Weiser Garbage
Collector. This increases the memory requirements of <a
href="http://ecls.sourceforge.net">ECL</a> with respect to the old
garbage collector, but the whole environment results faster and more robust.

<li><b>Improve the compiler: more agressive inlining, better operations among
numbers and unboxed arrays of complex numbers.</b>

<p><a href="http://ecls.sourceforge.net">ECL</a> currently can inline all
operations that involve fixnums, characters and floating point
numbers. However, the type inferencer is not very powerful and therefore some
operations are not inlined because the compiler cannot actually tell the types
of the arguments and of the output.
</ul>

