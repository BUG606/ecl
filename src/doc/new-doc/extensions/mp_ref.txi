@node Native threads reference
@subsection Native threads reference

@node Processes
@subsubsection Processes
@c src/c/threads/process.d

@cppindex mp_all_processes
@lspindex mp:all-processes

@deftypefun cl_object mp_all_processes ()
@end deftypefun

@defun mp:all-processes

Returns the list of processes associated to running tasks. The list is a
fresh new one and can be destructively modified. However, it may happen
that the output list is not up to date, because some of the tasks has
expired before this copy is returned.

@end defun


@cppindex mp_exit_process
@lspindex mp:exit-process

@deftypefun cl_object mp_all_processes () ecl_attr_noreturn
@end deftypefun

@defun mp:exit_process

When called from a running task, this function immediately causes the
task to finish. When invoked from the main thread, it is equivalent to
invoking @code{ext:quit} with exit code 0.

@end defun


@cppindex mp_interrupt_process
@lspindex mp:interrupt-process

@deftypefun cl_object mp_interrupt_process (cl_object process, cl_object function)
@end deftypefun

@defun mp:interrupt_process process function

Interrupt a task. This @code{function} sends a signal to a running
@code{process}. When the task is free to process that signal, it will
stop whatever it is doing and execute the given function.

@exindex Process interruption
Example:

Kill a task that is doing nothing (See @code{mp:process-kill}).

@lisp
(flet ((task-to-be-killed ()
         ;; Infinite loop
         (loop (sleep 1))))
  (let ((task (mp:process-run-function 'background #'task-to-be-killed)))
    (sleep 10)
    (mp:interrupt-process task 'mp:exit-process)))
@end lisp

@end defun


@cppindex mp_make_process
@lspindex mp:make-process

@deftypefun cl_object mp_make_process (cl_narg narg, ...)
@end deftypefun

@defun mp:make-process &key name initial-bindings

Create a new thread. This function creates a separate task with a name
set to @code {name}, set of variable bindings @code{initial-bindings}
and no function to run. See also @code{mp:process-run-function}. Returns
newly created process.

@end defun


@cppindex mp_process_active_p
@lspindex mp:process-active-p

@deftypefun cl_object mp_make_process (cl_object process)
@end deftypefun

@defun mp:process-active-p process

Returns @code{t} when @code{process} is active, @code {nil}
otherwise. Signals an error if @code{process} doesn't designate a valid
process.

@end defun


@cppindex mp_process_enable
@lspindex mp:process-enable

@deftypefun cl_object mp_process_enable (cl_object process)
@end deftypefun

@defun mp:process-enable process

The argument to this function should be a process created by
@code{mp:make-process}, which has a function associated as per
@code{mp:process-preset} but which is not yet running.  After invoking
this function a new thread will be created in which the associated
function will be executed.

@exindex Possible implementation of @code{mp:process-run-function}:

@lisp
(defun process-run-function (process-name process-function &rest args)
  (let ((process (mp:make-process name)))
    (apply #'mp:process-preset process function args)
    (mp:process-enable process)))
@end lisp
@end defun


@cppindex mp_process_yield
@lspindex mp:process_yield

@deftypefun cl_object mp_process_yield ()
@end deftypefun

@defun mp:process-yield
Yield the processor to other threads.
@end defun


@cppindex mp_process-join
@lspindex mp:process_join

@deftypefun cl_object mp_process_join (cl_object process)
@end deftypefun

@defun mp:process-join process
Suspend current thread until @code{process} exits. Return the result
values of the @code{process} function. If @code{process} is the current
thread, signal an error with.
@end defun


@cppindex mp_process_kill
@lspindex mp:process-kill

@deftypefun cl_object mp_process_kill (cl_object process)
@end deftypefun

@defun mp:process-kill process
Try to stop a running task. Killing a process may fail if the task has
disabled interrupts.

@exindex Killing process
Example:

Kill a task that is doing nothing
@lisp
(flet ((task-to-be-killed ()
         ;; Infinite loop
         (loop (sleep 1))))
  (let ((task (mp:process-run-function 'background #'task-to-be-killed)))
    (sleep 10)
    (mp:process-kill task)))
@end lisp
@end defun


@cppindex mp_process_suspend
@lspindex mp:process-suspend

@deftypefun cl_object mp_process_suspend (cl_object process)
@end deftypefun

@defun mp:process-suspend process
Suspend a running @code{process}. May be resumed with
@code{mp:process-resume}.

@exindex Suspend and resume process
Example:

@lisp
(flet ((ticking-task ()
         ;; Infinite loop
         (loop
            (sleep 1)
            (print :tick))))
  (print "Running task (one tick per second)")
  (let ((task (mp:process-run-function 'background #'ticking-task)))
    (sleep 5)
    (print "Suspending task for 5 seconds")
    (mp:process-suspend task)
    (sleep 5)
    (print "Resuming task for 5 seconds")
    (mp:process-resume task)
    (sleep 5)
    (print "Killing task")
    (mp:process-kill task)))
@end lisp
@end defun


@cppindex mp_process_resume
@lspindex mp:process-resume

@deftypefun cl_object mp_process_resume (cl_object process)
@end deftypefun

@defun mp:process-resume process
Resumes a suspended @code{process}. See example in
@code{mp:process-suspend}.
@end defun


@cppindex mp_process_name
@lspindex mp:process-name

@deftypefun cl_object mp_process_name (cl_object process)
@end deftypefun

@defun mp:process-name process
Returns the name of a @code{process} (if any).
@end defun


@cppindex mp_process_preset
@lspindex mp:process-preset

@deftypefun cl_object mp_process_preset (cl_narg narg, cl_object process, cl_object function, ...)
@end deftypefun

@defun mp:process-preset process function &rest function-args

Associates a @code{function} to call with the arguments
@code{function-args}, with a stopped @code{process}. The function will
be the entry point when the task is enabled in the future.

See @code{mp:enable-process} and @code{mp:process-run-function}.

@end defun


@cppindex mp_process_run_function
@lspindex mp:process-run-function

@deftypefun cl_object mp_process_run_function (cl_narg narg, cl_object name, cl_object function, ...)
@end deftypefun

@defun mp:process_run_function name function &rest funciton-args
Create a new process using @code{mp:make-process}, associate a function
to it and start it using @code{mp:process-preset}.

@exindex mp:process-run-funciton usage
Example:

@lisp
(flet ((count-numbers (end-number)
         (dotimes (i end-number)
	   (format t "~%;;; Counting: ~i" i)
	   (terpri)
	   (sleep 1))))
  (mp:process-run-function 'counter #'count-numbers 10))
@end lisp
@end defun


@cppindex mp_current_process
@lspindex mp:current_process

@deftypefun cl_object mp_current_process ()
@end deftypefun

@defun mp:current-process
Returns the current process of a caller.
@end defun


@c condition variables
@node Condition variables
@subsubsection Condition variables


@cppindex mp_make_condition_variable
@lspindex mp:make-condition-variable

@deftypefun cl_object mp_make_condition_variable ()
@end deftypefun

@defun mp:make-condition-variable

@end defun

@lspindex mp:condition_variable_wait
@cppindex mp_condition_variable_wait
@defun mp:condition_variable_wait
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_condition_variable_wait(cl_object cv, cl_object lock);
@end table
@end defun

@lspindex mp:condition_variable_timedwait
@cppindex mp_condition_variable_timedwait
@defun mp:condition_variable_timedwait
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_condition_variable_timedwait(cl_object cv, cl_object lock, cl_object seconds);
@end table
@end defun

@lspindex mp:condition_variable_signal
@cppindex mp_condition_variable_signal
@defun mp:condition_variable_signal
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_condition_variable_signal(cl_object cv);
@end table
@end defun

@lspindex mp:condition_variable_broadcast
@cppindex mp_condition_variable_broadcast
@defun mp:condition_variable_broadcast
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_condition_variable_broadcast(cl_object cv);
@end table
@end defun

@lspindex mp:block_signals
@cppindex mp_block_signals
@defun mp:block_signals
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_block_signals(void);
@end table
@end defun

@lspindex mp:restore_signals
@lspindex mp_restore_signals
@defun mp:restore_signals
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_restore_signals(cl_object sigmask);
@end table
@end defun

bool ecl_import_current_thread(cl_object process_name, cl_object process_binding);
void ecl_release_current_thread(void);

@node Locks
@subsubsection Locks (mutexes)
/* threads/process.d */

@lspindex mp:make_lock
@cppindex mp_make_lock
@defun mp:make_lock
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_make_lock _ECL_ARGS((cl_narg narg, ...));
@end table
@end defun

@lspindex mp:recursive_lock_p
@lspindex mp_recursive_lock_p
@defun mp:recursive_lock_p
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_recursive_lock_p(cl_object lock);
@end table
@end defun

@lspindex mp:holding_lock_p
@lspindex mp_holding_lock_p
@defun mp:holding_lock_p
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_holding_lock_p(cl_object lock);
@end table
@end defun

@lspindex mp:lock_name
@lspindex mp_lock_name
@defun mp:lock_name
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_lock_name(cl_object lock);
@end table
@end defun

@lspindex mp:lock_owner
@lspindex mp_lock_owner
@defun mp:lock_owner
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_lock_owner(cl_object lock);
@end table
@end defun

@lspindex mp:lock_count
@lspindex mp_lock_count
@defun mp:lock_count
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_lock_count(cl_object lock);
@end table
@end defun

@lspindex mp:get_lock
@lspindex mp_get_lock
@defun mp:get_lock
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_get_lock _ECL_ARGS((cl_narg narg, cl_object lock, ...));
@end table
@end defun

@lspindex mp:get_lock_wait
@lspindex mp_get_lock_wait
@defun mp:get_lock_wait
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_get_lock_wait(cl_object lock);
@end table
@end defun

@lspindex mp:get_lock_nowait
@lspindex mp_get_lock_nowait
@defun mp:get_lock_nowait
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_get_lock_nowait(cl_object lock);
@end table
@end defun

@lspindex mp:giveup_lock
@lspindex mp_giveup_lock
@defun mp:giveup_lock
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_giveup_lock(cl_object lock);
@end table
@end defun

cl_object ecl_make_lock(cl_object lock, bool recursive);

@node Read-Write locks
@subsubsection Read-Write locks
/* threads/rwlock.d */

@lspindex mp:make_rwlock
@lspindex mp_make_rwlock
@defun mp:make_rwlock
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_make_rwlock _ECL_ARGS((cl_narg narg, ...));
@end table
@end defun

@lspindex mp:rwlock_name
@lspindex mp_rwlock_name
@defun mp:rwlock_name
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_rwlock_name(cl_object lock);
@end table
@end defun

@lspindex mp:get_rwlock_read
@lspindex mp_get_rwlock_read
@defun mp:get_rwlock_read
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_get_rwlock_read _ECL_ARGS((cl_narg narg, cl_object lock, ...));
@end table
@end defun

@lspindex mp:get_rwlock_write
@lspindex mp_get_rwlock_write
@defun mp:get_rwlock_write
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_get_rwlock_write _ECL_ARGS((cl_narg narg, cl_object lock, ...));
@end table
@end defun

@lspindex mp:giveup_rwlock_read
@lspindex mp_giveup_rwlock_read
@defun mp:giveup_rwlock_read
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_giveup_rwlock_read(cl_object lock);
@end table
@end defun

@lspindex mp:giveup_rwlock_write
@lspindex mp_giveup_rwlock_write
@defun mp:giveup_rwlock_write
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_giveup_rwlock_write(cl_object lock);
@end table
@end defun

cl_object ecl_make_rwlock(cl_object lock);

@node Semaphores
@subsubsection Semaphores
/* threads/semaphore.d */

@lspindex mp:make_semaphore
@lspindex mp_make_semaphore
@defun mp:make_semaphore
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_make_semaphore _ECL_ARGS((cl_narg, ...));
@end table
@end defun

@lspindex mp:semaphore_count
@lspindex mp_semaphore_count
@defun mp:semaphore_count
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_semaphore_count(cl_object);
@end table
@end defun

@lspindex mp:semaphore_name
@lspindex mp_semaphore_name
@defun mp:semaphore_name
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_semaphore_name(cl_object);
@end table
@end defun

@lspindex mp:semaphore_wait_count
@lspindex mp_semaphore_wait_count
@defun mp:semaphore_wait_count
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_semaphore_wait_count(cl_object);
@end table
@end defun

@lspindex mp:wait_on_semaphore
@lspindex mp_wait_on_semaphore
@defun mp:wait_on_semaphore
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_wait_on_semaphore(cl_object);
@end table
@end defun

@lspindex mp:try_get_semaphore
@lspindex mp_try_get_semaphore
@defun mp:try_get_semaphore
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_try_get_semaphore(cl_object);
@end table
@end defun

@lspindex mp:signal_semaphore
@lspindex mp_signal_semaphore
@defun mp:signal_semaphore
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_signal_semaphore _ECL_ARGS((cl_narg, cl_object, ...));
@end table
@end defun

cl_object ecl_make_semaphore(cl_object name, cl_fixnum count);

@node Barriers
@subsubsection Barriers
/* threads/barrier.d */

@lspindex ecl_make_barrier
cl_object ecl_make_barrier(cl_object name, cl_index count);
cl_object mp:make_barrier _ECL_ARGS((cl_narg, cl_object, ...));
cl_object mp_make_barrier _ECL_ARGS((cl_narg, cl_object, ...));
@defun mp:make_barrier _ECL_ARGS((cl_narg, cl_object, ...));
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_barrier_count(cl_object);
@end table
@end defun

@lspindex mp:barrier_name
@lspindex mp_barrier_name
@defun mp:barrier_name
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_barrier_name(cl_object);
@end table
@end defun

@lspindex mp:barrier_arrivers_count
@lspindex mp_barrier_arrivers_count
@defun mp:barrier_arrivers_count
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_barrier_arrivers_count(cl_object);
@end table
@end defun

@lspindex mp:barrier_wait
@lspindex mp_barrier_wait
@defun mp:barrier_wait
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_barrier_wait _ECL_ARGS((cl_narg, cl_object, ...));
@end table
@end defun

cl_object mp_barrier_unblock _ECL_ARGS((cl_narg, cl_object, ...));

@node Mailboxes
@subsubsection Mailboxes
/* threads/mailbox.d */

@lspindex mp:make_mailbox
@lspindex mp_make_mailbox
@defun mp:make_mailbox
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_make_mailbox _ECL_ARGS((cl_narg, ...));
@end table
@end defun

@lspindex mp:mailbox_name
@lspindex mp_mailbox_name
@defun mp:mailbox_name
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_mailbox_name(cl_object mailbox);
@end table
@end defun

@lspindex mp:mailbox_count
@lspindex mp_mailbox_count
@defun mp:mailbox_count
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_mailbox_count(cl_object mailbox);
@end table
@end defun

@lspindex mp:mailbox_empty_p
@lspindex mp_mailbox_empty_p
@defun mp:mailbox_empty_p
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_mailbox_empty_p(cl_object);
@end table
@end defun

@lspindex mp:mailbox_read
@lspindex mp_mailbox_read
@defun mp:mailbox_read
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_mailbox_read(cl_object mailbox);
@end table
@end defun

@lspindex mp:mailbox_try_read
@lspindex mp_mailbox_try_read
@defun mp:mailbox_try_read
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_mailbox_try_read(cl_object mailbox);
@end table
@end defun

@lspindex mp:mailbox_send
@lspindex mp_mailbox_send
@defun mp:mailbox_send
@table @var
@item returns
???
@item C/C++ signature
cl_object mp_mailbox_send(cl_object mailbox, cl_object msg);
@end table
@end defun

cl_object mp_mailbox_try_send(cl_object mailbox, cl_object msg);

@node Atomic operations
@subsubsection Atomic operations
/* threads/atomic.c */

cl_object ecl_atomic_get(cl_object *slot);
void ecl_atomic_push(cl_object *slot, cl_object o);
void ecl_atomic_nconc(cl_object l, cl_object *slot);
cl_object ecl_atomic_pop(cl_object *slot);
cl_index ecl_atomic_index_incf(cl_index *slot);
