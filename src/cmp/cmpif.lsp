;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

;;;; CMPIF  Conditionals.

(in-package "COMPILER")

(defun c1if (args &aux info f)
  (when (or (endp args) (endp (cdr args)))
        (too-few-args 'if 2 (length args)))
  (unless (or (endp (cddr args)) (endp (cdddr args)))
          (too-many-args 'if 3 (length args)))
  (setq f (c1fmla-constant (car args)))
  (case f
        ((T) (c1expr (second args)))
        ((NIL) (if (endp (cddr args)) (c1nil) (c1expr (third args))))
        (otherwise
         (setq info (make-info))
         (list 'IF info
               (c1fmla f info)
               (c1expr* (second args) info)
               (if (endp (cddr args)) (c1nil) (c1expr* (third args) info)))))
  )

(defun c1fmla-constant (fmla &aux f)
  (cond
   ((consp fmla)
    (case (car fmla)
          (AND (do ((fl (cdr fmla) (cdr fl)))
                   ((endp fl) t)
		 (setq f (c1fmla-constant (car fl)))
		 (case f
		   ((T))
		   ((NIL) (return nil))
		   (t (if (endp (cdr fl))
			  (return f)
			  (return (list* 'AND f (cdr fl))))))))
          (OR (do ((fl (cdr fmla) (cdr fl)))
                  ((endp fl) nil)
		(setq f (c1fmla-constant (car fl)))
		(case f
		  ((T) (return t))
		  ((NIL))
		  (t (if (endp (cdr fl))
			 (return f)
			 (return (list* 'OR f (cdr fl))))))))
          ((NOT NULL)
           (when (endp (cdr fmla)) (too-few-args 'not 1 0))
           (unless (endp (cddr fmla))
                   (too-many-args 'not 1 (length (cdr fmla))))
           (setq f (c1fmla-constant (second fmla)))
           (case f
                 ((T) nil)
                 ((NIL) t)
                 (t (list 'NOT f))))
          (t fmla)))
   ((symbolp fmla) (if (constantp fmla)
                       (if (symbol-value fmla) t nil)
                       fmla))
   (t t))
  )

(defun c1fmla (fmla info)
  (if (consp fmla)
      (case (car fmla)
            (AND (case (length (cdr fmla))
                   (0 (c1t))
                   (1 (c1fmla (second fmla) info))
                   (t (cons 'FMLA-AND
                            (mapcar #'(lambda (x) (c1fmla x info))
                                    (cdr fmla))))))
            (OR (case (length (cdr fmla))
                   (0 (c1nil))
                   (1 (c1fmla (second fmla) info))
                   (t (cons 'FMLA-OR
                            (mapcar #'(lambda (x) (c1fmla x info))
                                    (cdr fmla))))))
            ((NOT NULL)
                  (when (endp (cdr fmla)) (too-few-args 'not 1 0))
                  (unless (endp (cddr fmla))
                          (too-many-args 'not 1 (length (cdr fmla))))
                  (list 'FMLA-NOT (c1fmla (second fmla) info)))
            (t (c1expr* fmla info)))
      (c1expr* fmla info))
  )

(defun c2if (fmla form1 form2
                  &aux (Tlabel (next-label)) Flabel)
  (cond ((and (eq (car form2) 'LOCATION)
              (null (third form2))
              (eq *destination* 'TRASH)
              (not (eq *exit* 'RETURN)))
         (let ((exit *exit*)
               (*unwind-exit* (cons Tlabel *unwind-exit*))
               (*exit* Tlabel))
              (CJF fmla Tlabel exit))
         (wt-label Tlabel)
         (c2expr form1))
        (t
         (setq Flabel (next-label))
         (let ((*unwind-exit* (cons Flabel (cons Tlabel *unwind-exit*)))
               (*exit* Tlabel))
              (CJF fmla Tlabel Flabel))
         (wt-label Tlabel)
         (let ((*unwind-exit* (cons 'JUMP *unwind-exit*))
	       (*temp* *temp*))
	   (c2expr form1))
         (wt-label Flabel)
         (c2expr form2)))
  )

;;; If fmla is true, jump to Tlabel.  If false, do nothing.
(defun CJT (fmla Tlabel Flabel)
  (case (car fmla)
    (FMLA-AND (do ((fs (cdr fmla) (cdr fs)))
                  ((endp (cdr fs))
                   (CJT (car fs) Tlabel Flabel))
                (let* ((label (next-label))
                       (*unwind-exit* (cons label *unwind-exit*)))
                  (CJF (car fs) label Flabel)
                  (wt-label label))))
    (FMLA-OR (do ((fs (cdr fmla) (cdr fs)))
                 ((endp (cdr fs))
                  (CJT (car fs) Tlabel Flabel))
               (let* ((label (next-label))
                      (*unwind-exit* (cons label *unwind-exit*)))
                 (CJT (car fs) Tlabel label)
                 (wt-label label))))
    (FMLA-NOT (CJF (second fmla) Flabel Tlabel))
    (LOCATION
     (case (third fmla)
       ((T) (unwind-no-exit Tlabel) (wt-nl) (wt-go Tlabel))
       ((NIL))
       (t (let ((*destination* (list 'JUMP-TRUE Tlabel)))
            (c2expr* fmla)))))
    (t (let ((*destination* (list 'JUMP-TRUE Tlabel))) (c2expr* fmla))))
  )

;;; If fmla is false, jump to Flabel.  If true, do nothing.
(defun CJF (fmla Tlabel Flabel)
  (case (car fmla)
    (FMLA-AND (do ((fs (cdr fmla) (cdr fs)))
                  ((endp (cdr fs)) (CJF (car fs) Tlabel Flabel))
                (declare (object fs))
                (let* ((label (next-label))
                       (*unwind-exit* (cons label *unwind-exit*)))
                  (CJF (car fs) label Flabel)
                  (wt-label label))))
    (FMLA-OR (do ((fs (cdr fmla) (cdr fs)))
                 ((endp (cdr fs)) (CJF (car fs) Tlabel Flabel))
               (declare (object fs))
               (let* ((label (next-label))
                      (*unwind-exit* (cons label *unwind-exit*)))
                 (CJT (car fs) Tlabel label)
                 (wt-label label))))
    (FMLA-NOT (CJT (second fmla) Flabel Tlabel))
    (LOCATION
     (case (third fmla)
       ((T))
       ((NIL) (unwind-no-exit Flabel) (wt-nl) (wt-go Flabel))
       (t (let ((*destination* (list 'JUMP-FALSE Flabel)))
            (c2expr* fmla)))))
    (t (let ((*destination* (list 'JUMP-FALSE Flabel))) (c2expr* fmla))))
  )

(defun c1and (args)
  (cond ((endp args) (c1t))
        ((endp (cdr args)) (c1expr (car args)))
        (t (let ((info (make-info))) (list 'AND info (c1args args info))))))

(defun c2and (forms)
  (do ((forms forms (cdr forms))
       (form))
      ((endp (cdr forms))
       (c2expr (car forms)))
    (declare (list forms))
    (setq form (first forms))
    (cond ((eq (car form) 'LOCATION)
           (case (third form)
             ((T))
             ((NIL) (unwind-exit nil 'JUMP))
             (t (wt-nl "if(" (third form) "==Cnil){")
                (unwind-exit nil 'JUMP) (wt "}")
                )))
          ((eq (car form) 'VAR)
           (wt-nl "if(" (third form) "==Cnil){")
           (unwind-exit nil 'JUMP) (wt "}"))
          (t
           (let* ((label (next-label))
                  (*unwind-exit* (cons label *unwind-exit*)))
             (let ((*destination* (list 'JUMP-TRUE label)))
               (c2expr* form))
             (unwind-exit nil 'JUMP)
             (wt-label label))))
      ))

(defun c1or (args)
  (cond ((endp args) (c1nil))
        ((endp (cdr args)) (c1expr (car args)))
        (t (let ((info (make-info)))
                (list 'OR info (c1args args info))))))

(defun c2or (forms &aux temp)
  (do ((forms forms (cdr forms))
       (form))
      ((endp (cdr forms))
       (c2expr (car forms)))
    (declare (list forms))
    (setq form (first forms))
    (cond ((eq (car form) 'LOCATION)
	   (case (third form)
	     ((T) (unwind-exit t 'JUMP))
	     ((NIL))
	     (t (wt-nl "if(" (third form) "!=Cnil){")
		(unwind-exit (third form) 'JUMP) (wt "}"))))
	  ((eq (car form) 'VAR)
	   (wt-nl "if(" (third form) "!=Cnil){")
	   (unwind-exit (third form) 'JUMP) (wt "}"))
	  ((and (eq (car form) 'CALL-GLOBAL)
		(get-sysprop (third form) 'PREDICATE))
	   (let* ((label (next-label))
		  (*unwind-exit* (cons label *unwind-exit*)))
	     (let ((*destination* (list 'JUMP-FALSE label)))
	       (c2expr* form))
	     (unwind-exit t 'JUMP)
	     (wt-label label)))
	  (t
	   (let* ((label (next-label))
		  (*unwind-exit* (cons label *unwind-exit*)))
	     ;; to hanlde (or (foo) ..), since foo may be inlined,
	     ;; we force the result into VALUES(0)
	     (let ((*destination* 'RETURN)) (c2expr* form))
	     (wt-nl "if(value0==Cnil)") (wt-go label)
	     (unwind-exit 'RETURN 'JUMP)
	     (wt-label label))))
    )
  )

(defun set-jump-true (loc label)
  (cond ((null loc))
	((eq loc t)
	 (unwind-no-exit label)
	 (wt-nl) (wt-go label))
	(t
	 (cond ((eq (loc-representation-type loc) :bool)
		(wt-nl "if(" loc "){"))
	       (t
		(wt-nl "if((")
		(wt-coerce-loc :object loc)
		(wt ")!=Cnil){")))
	 (unwind-no-exit label)
	 (wt-nl) (wt-go label)
	 (wt "}"))))

(defun set-jump-false (loc label)
  (cond ((eq loc t))
	((null loc)
	 (unwind-no-exit label)
	 (wt-nl) (wt-go label))
	(t
	 (cond ((eq (loc-representation-type loc) :bool)
		(wt-nl "if(!(" loc ")){"))
	       (t
		(wt-nl "if((")
		(wt-coerce-loc :object loc)
		(wt ")==Cnil){")))
	 (unwind-no-exit label)
	 (wt-nl) (wt-go label)
	 (wt "}"))))

;;; ----------------------------------------------------------------------

(put-sysprop 'if 'c1special #'c1if)
(put-sysprop 'if 'c2 #'c2if)
(put-sysprop 'and 'c1 #'c1and)
(put-sysprop 'and 'c2 #'c2and)
(put-sysprop 'or 'c1 #'c1or)
(put-sysprop 'or 'c2 #'c2or)

(put-sysprop 'jump-true 'set-loc #'set-jump-true)
(put-sysprop 'jump-false 'set-loc #'set-jump-false)
