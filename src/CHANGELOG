ECL 0.9k:
=========

* Visible changes:

 - The documentation is slowly disappearing form this source tree, as there
   is a different tree (ecl-doc) which contains the XML sources for a more
   complete manual.

 - RENAME-FILE now accepts a keyword argument :IF-EXISTS, which defines the
   behavior when a file with the new name already exists (Geo Carncross).

 - Improved hashing on 64-bit machines.

 - The physical pathname format has changed from [device:][[//hostname]/]...
   to [[device:[//hostname]]/]... The reason is that this allows proper
   parsing of Unix pathnames such as "//usr/".

 - In interpreted functions, blocks are only created when used. The current
   algorithm for detecting unused blocks is inefficient, with a performance
   penalty 2^{# unused blocks}, but this seems to pay off when running the
   interpreted code, due to decreased consing
	> (defun foo () )         
	FOO
	> (time (dotimes (i 100000) (foo)))
	real time : 0.045 secs
	run time  : 0.048 secs
	gc count  : 1 times
	consed    : 160 bytes
   Formerly, this would cons 3200192 bytes.

 - When compiling object files that will form part of either a unified FASL or
   of a library (static or dynamically linked), there used to be name
   collisions between the initialization functions of different modules. Now
   ECL uses a cleverer hashing algorithm to name these functions, storing the
   key in a string in the object file, which is later searched before linking
   the file.  Currently the hash key only depends on the pathname of the source
   file and the universal time at which is compiled, hence there may still be
   collisions between files compiled on different machines. In short: you should
   only worry if you regularly use the function C::BUILD.

 - Improved hashing of unicode strings.

 - ECL ships with ASDF v1.111

 - We now activate CMUCL's implementation of FORMATTER, which compiles format
   strings into lisp functions, instead of a dummy function that calls
   FORMAT. This leads to some speedup when pretty-printing.

 - When using (OPTIMIZE (DEBUG n)) for n >= 1, calls to functions in the same
   file are not inlined and always go through cl_funcall. This way they show up
   in backtraces in the debugger, and the function can be traced and profiled.

 - Declaration SI:C-LOCAL is deactivated by (DEBUG > 0).

 - Ported CMUCL's profiler as a contributed package.

 - Gray streams are now implemented in a separate package, called GRAY, which
   exports symbols such as FUNDAMENTAL-STREAM or STREAM-READ-CHAR.

 - The functions CLOSE, {OPEN,INPUT,OUTPUT}-STREAM-P, STREAM-P and
   STREAM-ELEMENT-TYPE are now offered in two flavors. The versions exported by
   the COMMON-LISP package are ordinary functions, the versions in the GRAY
   package are generic functions that can be specialized to new classes. The
   ordinary functions will invoke the generic version when passed a generic
   stream. Note that, for instance, CL:CLOSE and GRAY:CLOSE are not the same
   symbol. This means you might need to shadow-import the symbols associated to
   generic versions in the packages where methods on these functions are
   defined.

* CLOS:

 - When caching generic function calls, ECL now uses a thread-local hash table
   instead of one hash table per generic function.

* Bugs fixed:

 - The bignums produced by RANDOM did not have enough random bits.

 - ECL formerly accepted spaces between the comma and the @ and . characters
   in expressions like ,@ or ,.

 - Building a statically linked ECL works again.

 - Equal random states now compare properly under EQUALP and their hash keys
   are also equal.

 - Problems in the use of "volatile" keywords prevented ECL from compiling
   with a C++ compiler.

 - The reader function for #\ was not suitable for being invoked by the
   user on an arbitrary stream.

 - ECL tried to use intel-64bits assembler on 64 bits processors, even when
   compiler and the operating system work with 32bits.

 - The compiler now inlines and optimizes (FUNCALL (X ..) ... ) where X is a
   macro that returns a lambda form.

 - ECL no longer needs library definition files ecl.def and ecl-threads.def
   thanks to a more clever use of declarations __declspec(dllexport) and
   __declspec(dllimport).

 - We no longer use the flag --rpath when building ECL. Given the fact that
   ECL now assumes a standard Unix filesystem structure, this should pose no
   problem. For nonstandard locations, you will have to define LD_LIBRARY_PATH

* System design:

 - We introduce a new kind of lisp objects, the stack frames. These are objects
   with dynamical extent, which work as adjustable arrays and are mainly used
   for collecting the arguments of a function, in MAP, MAPCAR, APPLY, FUNCALL,
   MULTIPLE-VALUE-CALL, etc.

;;; Local Variables: ***
;;; mode:text ***
;;; fill-column:79 ***
;;; End: ***
