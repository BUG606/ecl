ECL 0.9i
========

* New platforms:

 - Patches in assembler code and GC headers to build ECL on Mac OSX/Intel
   contributed by Brad Beveridge. This port relies on the version of the
   GNU MP library shipped with DarwinPorts.

 - ECL compiles and passes tests in OpenBSD/x86.

* Visible changes:

 - Many functions have got now the prefix "ecl_" so as to avoid namespace
   collisions with C/C++ code.

 - Several functions with duplicate functionality (make_two_way_streams,
   make_string_output_stream_from_string, close_stream, etc) have been removed.

 - A new global variable EXT:*ACTION-ON-UNDEFINED-VARIABLE* controls whether
   the interpreter complains when you try to assign a value to a symbol that
   has not been defined as variable. An example

	> (SETQ S 1)	; No complain
	1
	> (SETQ EXT:*ACTION-ON-UNDEFINED-VARIABLE* 'ERROR)
	ERROR
	> (SETQ X 1)	; Ooops, X had not been defined before!
	Undefined variable referenced in interpreted code.
	Name: X
	>> :q
	> (DEFVAR X 1)
	X
	> (SETQ X 1)
	1

 - Adding a new method to a generic function does no longer result in a warning
   when the function belongs to a locked package.

 - Trying to change the function definition of a symbol in a locked package
   results in a correctable error.

 - All filesystem operations (opening files, checking directories, etc), now
   merge the pathname not only with *default-pathname-defaults*, but also with
   the output of SI:GETCWD. This way we ensure that all filenames are absolute
   pathnames. [1]

 - *LOAD-PATHNAME* contains the pathname as passed to LOAD, merged with
   *DEFAULT-PATHNAME-DEFAULTS* but not with SI:GETCWD. In other words, according
   to ANSI, it does not get the pathname as seen by the operating system.

 - C:BUILDER, C:BUILD-PROGRAM, etc, now accept :EPILOGUE-CODE to be a lisp
   form. This form is read and evaluated at run time after initializing the
   lisp core. A call to cl_shutdown() is automatically included afterwards for
   simplicity.

 - COMPILE-FILE-PATHNAME now accepts both :FASL and :FAS as type. They are
   synonyms.

 - cl_safe_eval() can now be used to invoke #'TOP-LEVEL because it uses a safer
   way to intercept errors, based on rebinding *debugger-hook*. The actual
   implementation is in top.lsp and made in lisp and can be used from lisp code
	> (si::safe-eval '(cos 'A) 'nil '2)
   Notice, though, that SAFE-EVAL ignores all enclosing handlers!
	> (handler-case (si:safe-eval '(cos 'A) nil 12)
	  (error (c) c))

 - When passed the option --help, -h or -?, ECL no longer loads the rc file
   (which is typically ~/.ecl or ~/.eclrc)

 - Header files are now included with a prefix, as in #include <ecl/ecl.h>
   or #include <ecl/config.h> to avoid collisions with other system files.

 - The function SI:PROCESS-COMMAND-ARGS has now a more flexible interface and
   can be used by standalone programs with user supplied rules.

 - Symbols in the core library are now referenced with a self-explanatory
   macro, as in ECL_SYM("SI::*EXIT-HOOKS*",1379) (Thanks to Douglas R. Miles
   for the idea).

 - The symbols from the AMOP are now exported from the CLOS package. This does
   not mean that everything has been implemented, but it makes the implemented
   options accessible.

 - Included support for multithreading under Windows/Cygwin (Thanks to Arthur
   Smyles for pointing out the differences from Linux's pthreads)

 - New manual file for 'ecl-config' contributed by Peter Van Eynde.

 - NIL is no longer a valid specializer in a method.

 - New SOCKET-SEND function, compatible with the SBCL one (contributed by
   Dmitri Hrapof).

 - ECL's compiler will complain sooner about unknown declarations.

 - It is now possible to change the buffering mode of non-Gray streams using
   the SI::SET-BUFFERING-MODE function that takes a stream and the mode as
   arguments. This is only guaranteed to work if the stream has not yet been
   written/read to. The buffering mode can be NIL (no buffer), T or
   :FULL-BUFFERED, or :LINE-BUFFERED.

 - SOCKET-MAKE-STREAM now takes an argument :BUFFERING-MODE with the same
   effect as SI::SET-BUFFERING-MODE's argument.

 - ECL can be built against locally installed copies of the Boehm-Weiser
   garbage collector, as far as they are recent. This has been checked with
   OpenBSD & Ubuntu. You may need to supply appropiate LDFLAGS & CFLAGS for the
   configuration to detect the headers.

 - ECL now can compile files with constants that do not print readably, such as
   CLOS objects. In those cases, MAKE-LOAD-FORM is used to recreate these
   constants. The only case where this fail is when the "unreadable" constant
   is part of a circular structure (contributed by Brian Spilsbury).

 - The second value of MACROEXPAND-1 is true whenever a macroexpansion
   happened; in other words, whenever an macro function was called. MACROEXPAND
   on the additionally checks whether the macroexpanded form is eq to the
   original one and complains of the infinite loop that results.

* MOP compatibility:

 - SLOT-VALUE, SLOT-BOUNDP, etc, together with MOP SLOT*-USING-CLASS generic
   functions now rely entirely on slot-definition objects.

 - Effective slot definitions now have a "location" slot. Around methods for
   COMPUTE-SLOTS assign a location to each slot definition that has allocation
   :INSTANCE or :CLASS.

 - A new defclass option, :OPTIMIZE-SLOT-ACCESS, which defaults to the value of
   CLOS:*OPTIMIZE-SLOT-ACCESS*, controls whether the slots accessors should
   address directly the values in the class or use SLOT-VALUE. It should be set
   to NIL when one intends to redefine the SLOT-*-USING-CLASS methods, and
   to T when trying to get the most of the speed.

 - Implemented [FUNCALLABLE-]STANDARD-INSTANCE-ACCESS. They are synonyms for
   SI:INSTANCE-REF and are, as such, inlined and _very_ unsafe. Use with care.

 - Two nonstandard slots have been removed from standard-methods. Keeping track
   of which methods were in a defgeneric function is done using the property
   list of the methods.

 - When a class inherits from two or more classes, slot definitions with the
   same name must be merged. In particular, when a slot has the same name in
   two parents, all accessors from all classes should be available for the
   child.

* Errors fixed:

 - The intermediate output of the compiler is written in the directory in which
   the output will reside. [1]

 - ENSURE-GENERIC-FUNCTION relies on ENSURE-GENERIC-FUNCTION-USING-CLASS for
   doing the real work of (re)defining generic functions. This means E-G-F now
   handles :METHOD-CLASS and :GENERIC-FUNCTION-CLASS properly.

 - Implemented the standard behavior of NO-APPLICABLE-METHOD. Formerly, ECL
   expected this function to simply fail and never return.

 - --disable-shared works again in Mingw. The header file external.h has to be
   modified at build time to remove a declaration "dllimport" which mingw does
   not support in the statically linked code. MSVC++ does not seem to have a
   problem with it, though.

 - It is now possible to define subclasses of STANDARD-CLASS. Before, some
   slots were not properly inherited by subclasses, causing errors when doing
   something like
	> (defclass foo (standard-class) ())
	> (defclass faa () () (:metaclass foo))

 - Callback functions are now 'static' so that the same names can be used
   in different files.

 - New method for DOCUMENTATION to operate on slot-definition objects.

 - New slot options are now allowed, as well as new metaclass options.

 - SLOT-{VALUE,BOUNDP,MAKUNBOUND}-USING-CLASS now are also specialized for
   standard-effective-slot-definition (Thanks to D. Corkill)

 - Constants are now implicitely declared global in the file in which they are
   defined, so that the compiler no longer issues warnings when they are
   referenced.

 - The slot GENERIC-FUNCTION of a method is initially set to NIL instead of
   left unbound.

 - The old conservative garbage collector works again. It now supports 64-bit
   architectures, though the memory is still limited to 32Mb of lisp data. In
   any case, this collector is only intended for small setups and OpenBSD.

 - The compiler transformed &AUX variables into a LET* form. In doing so, all
   declarations were propageted to the body of the LET* form, even those for
   non-&AUX variables. This could lead to spurious warnings about IGNORE
   declarations.

 - Fix the scope of special declarations in lambda forms so that they do not
   affect the initialization forms of optional, keyword and aux variables.
   Sample code:
	(defun foo (y)
	  (flet ((faa (&key (x y))
		   (declare (special y))
		   x))
	    (let ((y 4))
	      (declare (special y))
	      (faa))))
   A form (FOO 3) produced 4 before the bug was fixed.

 - The compiler now admits THE forms with type (VALUES ...), though they are
   ignored.

 - (DEFPACKAGE ... (:IMPORT NIL)) failed to import symbol NIL.

 - The compiler and the interpreter now share the same environment
   structure. This is important for issues like shadowing. Take the
   following code:
	(defmacro foo () 2)
	(defmacro test (symbol &environment env)
		(and (macro-function symbol env) t))
	(defun doit () (flet ((foo () 1)) (test foo))))
   If interpreted, DOIT is properly defined to return NIL, because the function
   FOO shadows the global macro definition. If compiled, MACRO-FUNCTION was
   unable to detect the shadowing definition. (B. Spilsbury)

* Documentation:

 - The HTML manuals now use CSS for a more appealing look.

* Notes:

 [1] Both bugs are related.

;;; Local Variables: ***
;;; mode:text ***
;;; fill-column:79 ***
;;; End: ***
