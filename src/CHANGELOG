ECL 0.9h
========

* Errors fixed:

 - The garbage collection of FASL files had been deactivated by the use of
   high level routines (VECTOR-PUSH-EXTEND) to handle the vector of weak
   pointers to the files.

 - MULTIPLE-VALUE-SETQ must output only the primary value.

 - MAKE-CONDITION now accepts type specifiers such as '(AND SIMPLE-CONDITION
   TYPE-ERROR).

 - LOAD can now load code from streams which are not associated to files.

 - DISASSEMBLE now signals a TYPE-ERROR condition when the argument is neither
   an extended function designator nor a lambda expression.

 - The block name of a function does not involve the the forms in the lambda
   list: i.e. (LAMBDA-EXT F (&aux (X (RETURN-FROM F 2)))) is no longer valid.

* Design:

 - Simplified the structure of the frame stack, removing redundant fields.

 - Reworked the structure of the lexical environment to accelerate access to
   variables.

 - New hash routine, similar to SBCL's one, faster and leading to fewer
   collisions between similar strings.

 - Method combinations do not longer rely on a hash table of precomputed
   effective methods. That method required a structural analysis of the forms
   generated by the method combinations, which is plain slower than generating
   the effective method as either a closure (in most cases) or as bytecodes
   (for the most complex declarative forms).

 - CALL-NEXT-METHOD and NEXT-METHOD-P are now implemented in a simpler way,
   without relying on the code walker (which is a damm buggy piece of code).

 - Formerly, the body of methods was walked through, replacing slot access with
   the indices of the slots in the object structure. This is plain wrong
   because the structure of a class may change. Such aggressive optimizations
   may be reimplemented in a future in the compiler, but only when the user
   asks for them.

 - The code walker is no longer needed and has been removed from the core.
   It will be available in the contributed packages.

 - Possibility of configure --without-gmp when cross-compiling (there are no
   true bignums then, just long long int if possible; doesn't work with native
   compilation because compiler needs true bignums).

 - ECL's own conservative garbage collector works again.

 - It is possible now to execute lisp code from threads that have been created
   by external C applications. The functions
	ecl_import_current_thread(cl_object name, cl_object bindings)
   should be called to register the current thread with the lisp world, while
	ecl_release_current_thread()
   should be invoked before the current thread exits. However, in order to
   ensure that the garbage collector can handle these threads, these
   applications must be compiled and linked against ECL so that the
   appropiate replacements for pthread_create()/CreateThread() are used.

 - On systems with GNU libc, we are able to signal and trap floating point
   exceptions of the following kinds: overflow, underflow and division by zero.
   Trapping of these exceptions can be disabled with (SI::TRAP-FPE NIL). In
   practice this means overflows in routines like EXP, EXPT, etc, are now
   detected.

* Visible changes:

 - The code for handling command line options has been redesigned. Now multiple
   -compile options are allowed; the -o/-c/-h/-data options have to come before
   the associated -compile; we introduce a new -rc option to force loading
   initialization files; errors during initialization are intercepted and cause
   ECL to abort.

 - Replacing GC_malloc with GC_malloc_ignore_offset() makes ECL use less
   memory. A 30% reduction observed when running the ANSI compatibility test
   suite.

* Foreign function interface (FFI):

 - Foreign function return type is now correctly handled, when it is specified
   with a user-defined foreign type that is an alias for a primitive type
   (M. Goffioul)

 - C-INLINE forms which contain :CSTRING as argument are now automatically
   rewritten in terms of WITH-CSTRING. This way, the null terminated strings
   that are generated at run time will not be garbage collected.

 - There is a primitive implementation of run-time automatic generation of
   interfaces to C functions. This allows us to call functions in shared
   libraries without need of the compiler. The current implementation only
   works on the intel architecture with GCC, but should be easily extended.

 - There is now a simple implementation of callbacks, with a syntax similar to
   that of CFFI:
	(ffi:defcallback foo :int ((a :int))
	   (1+ a))

 - On the intel x86 architecture we also have the possibility of creating
   callbacks dynamically, at run time, without the compiler.

;;; Local Variables: ***
;;; mode:text ***
;;; fill-column:79 ***
;;; End: ***
