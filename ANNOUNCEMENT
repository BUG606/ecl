Announcement of ECL v0.9h
=========================

ECL stands for Embeddable Common-Lisp. The ECL project aims to produce an
implementation of the Common-Lisp language which complies to the ANSI X3J13
definition of the language.

The term embeddable refers to the fact that ECL includes a lisp to C compiler,
which allows to produce libraries (static or dynamic) that can be called from C
programs. Furthermore, ECL can produce standalone executables from your lisp
code.

ECL supports the operating systems Linux, FreeBSD, NetBSD, OpenBSD, Solaris (at
least v. 9), Microsoft Windows and OSX, running on top of the Intel, Sparc,
Alpha and PowerPC processors. Porting to other architectures should be rather
easy.

ECL is currently hosted at SourceForge. The home page of the project is
http://ecls.sourceforge.net, and in it you will find source code releases, a
CVS tree and some useful documentation.

Notes for this release
======================

Apart from important bugs being fixed, this release makes slightly better use
of the Boehm-Weiser garbage collector, thereby reducing memory use. Typically,
in a linux/x86 box this can be as little as 6Mb of which 2.7Mb are shared
libraries (including both lisp and C libraries).

Another highlight of this release are the improvements in the foreign function
interface. First of all, callbacks are now supported for all architectures
using compiled code. Second, we have new, nonportable code for dynamically
accessing C/C++ functions in shared libraries, as well as creating callbacks on
the fly. Due to the need for assembly code, this is currently supported on the
Intel-x86 architecture only, but can be extended to other ports.

Also of interests are the ASDF routines introduced by Michael Goffioul for
building unified FASL files, shared libraries and standalone executables up
from a single system definition file. For a simple example see
     ecls/examples/asdf/readme.lisp

Finally, we have added a new platform to our list: OpenBSD. This port benefits
from the changes in ECL's own conservative garbage collector, which, at the
cost of being slightly slower, is the only one supported on this operating
system.

ECL 0.9h
========

* Platforms:

 - Ported to OpenBSD/x86. Might also work on other architectures.

* Errors fixed:

 - The garbage collection of FASL files had been deactivated by the use of
   high level routines (VECTOR-PUSH-EXTEND) to handle the vector of weak
   pointers to the files.

 - MULTIPLE-VALUE-SETQ must output only the primary value.

 - MAKE-CONDITION now accepts type specifiers such as '(AND SIMPLE-CONDITION
   TYPE-ERROR).

 - LOAD can now load code from streams which are not associated to files.

 - DISASSEMBLE now signals a TYPE-ERROR condition when the argument is neither
   an extended function designator nor a lambda expression.

 - The block name of a function does not involve the the forms in the lambda
   list: i.e. (LAMBDA-EXT F (&aux (X (RETURN-FROM F 2)))) is no longer valid.

 - Many of the STRING* functions (STRING=, STRING<, etc) were proclaimed to
   work only on strings, instead of string-designators.

 - The command line option "-s" does not take any arguments.

 - In ECL, all complex types are upgraded to (COMPLEX REAL). However, parts
   SUBTYPEP did not apply this.

 - When reading 1/0, the reader must signal a READER-ERROR, because it is
   a syntax error to have a denominator full of zeros (CLHS 2.2 end plus
   2.3.2.1.2).

 - When a DEFMETHOD form had an incongruent lambda list, an internal error
   prevented ECL from writing the proper error message.

 - SUBTYPEP formerly broken when handling (EQL #C(...))

 - Fixed several type propagations: for instance, the compiler assumed that
   SQRT of a real number is always real.

 - DECODE/ENCODE-UNIVERSAL-TIME now work with very big dates, although the
   accuracy for determining whether a time belongs to DAY-SAVING-TIME might
   depend on the implementation of the C library.

 - Most systems do not support dates before 1970 or after 2038. For guessing
   the daylight saving time property we shift the dates to equivalent years
   within this range.

* Design:

 - Simplified the structure of the frame stack, removing redundant fields.

 - Reworked the structure of the lexical environment to accelerate access to
   variables.

 - New hash routine, similar to SBCL's one, faster and leading to fewer
   collisions between similar strings.

 - Method combinations do not longer rely on a hash table of precomputed
   effective methods. That method required a structural analysis of the forms
   generated by the method combinations, which is plain slower than generating
   the effective method as either a closure (in most cases) or as bytecodes
   (for the most complex declarative forms).

 - CALL-NEXT-METHOD and NEXT-METHOD-P are now implemented in a simpler way,
   without relying on the code walker (which is a damm buggy piece of code).

 - Formerly, the body of methods was walked through, replacing slot access with
   the indices of the slots in the object structure. This is plain wrong
   because the structure of a class may change. Such aggressive optimizations
   may be reimplemented in a future in the compiler, but only when the user
   asks for them.

 - The code walker is no longer needed and has been removed from the core.
   It will be available in the contributed packages.

 - Possibility of configure --without-gmp when cross-compiling (there are no
   true bignums then, just long long int if possible; doesn't work with native
   compilation because compiler needs true bignums).

 - ECL's own conservative garbage collector works again.

 - It is possible now to execute lisp code from threads that have been created
   by external C applications. The functions
	ecl_import_current_thread(cl_object name, cl_object bindings)
   should be called to register the current thread with the lisp world, while
	ecl_release_current_thread()
   should be invoked before the current thread exits. However, in order to
   ensure that the garbage collector can handle these threads, these
   applications must be compiled and linked against ECL so that the
   appropiate replacements for pthread_create()/CreateThread() are used.

 - On some systems we are able to signal and trap floating point
   exceptions of the following kinds: overflow, underflow and division by zero.
   Trapping of these exceptions can be disabled with (SI::TRAP-FPE T NIL). In
   practice this means overflows in routines like EXP, EXPT, etc, are now
   detected.

* Visible changes:

 - The code for handling command line options has been redesigned. Now multiple
   -compile options are allowed; the -o/-c/-h/-data options have to come before
   the associated -compile; we introduce a new -rc option to force loading
   initialization files; errors during initialization are intercepted and cause
   ECL to abort.

 - Replacing GC_malloc with GC_malloc_ignore_offset() makes ECL use less
   memory. A 30% reduction observed when running the ANSI compatibility test
   suite.

 - Creating arrays with element type NIL now raises an error.

 - The DEFSYSTEM system definition facility v 3.4 is now distributed with ECL
   in the directory of external packages (contrib/defsystem).

 - The version of ASDF distributed with ECL supports building single FASL
   files, shared libraries and standalone executable files from a single
   definition file.

 - The test suites are now part of a separate project, ecls-test, that is only
   distributed via CVS from Sourceforge.

* Foreign function interface (FFI):

 - Foreign function return type is now correctly handled, when it is specified
   with a user-defined foreign type that is an alias for a primitive type
   (M. Goffioul)

 - C-INLINE forms which contain :CSTRING as argument are now automatically
   rewritten in terms of WITH-CSTRING. This way, the null terminated strings
   that are generated at run time will not be garbage collected.

 - There is a primitive implementation of run-time automatic generation of
   interfaces to C functions. This allows us to call functions in shared
   libraries without need of the compiler. The current implementation only
   works on the intel architecture with GCC, but should be easily extended.
   It can be turned on/off for individual compilations with variable
   SI::*USE-DFFI* (default is on if supported).

 - There is now a simple implementation of callbacks, with a syntax similar to
   that of CFFI:
	(ffi:defcallback foo :int ((a :int))
	   (1+ a))

 - On the intel x86 architecture we also have the possibility of creating
   callbacks dynamically, at run time, without the compiler.

;;; Local Variables: ***
;;; mode:text ***
;;; fill-column:79 ***
;;; End: ***
