Announcement of ECLS v0.5
=========================

ECLS stands for Embeddable Common-Lisp "Spain", and I usually read it
as "e-klos". It is a an implementation of the Common-Lisp language
which aims to comply to the ANSI X3J13 definition of the language.

ECLS is currently hosted at SourceForge. The home page of the project
is http://ecls.sourceforge.net, and in it you will find source code
releases, a CVS tree and an up to date documentation.

Notes about ECLS 0.5
====================

This release represents a major improvement over previous ones in
the number of supported platforms:

	- Debian Linux on Intel
	- Debian Linux on PowerPC
	- FreeBSD 4.x on Intel
	- Cygwin on Microsoft Windows 2000

Besides, the code has been revised and porting should now be easier.

ECLS 0.5
=========

* Errors fixed:

  - libclos.a should be installed together with libecls.a and liblsp.a

  - PROBE-FILE would not translate logical pathnames before checking for
    file existence.

  - In unsafe mode, inlining AREF lead to bogus code.

  - The order of evaluation of arguments in a PSETQ was not respected.

  - The compiler would not restore the value of a special variable which
    is used in MULTIPLE-VALUE-BIND.

  - The compiler produced wrong code for CATCH forms in which the tag
    is not constant.

  - The compiler produced wrong code for RETURN-FROM forms inside an
    UNWIND-PROTECT.

  - Deftype BIT-VECTOR would not expand to a vector type.

* System design and portability:

  - Remove function_entry_table.

  - Each compiled file has an entry point whose name is either
    init_CODE() or another name based on the name of the source file.
    The algorithm for computing these names has been slightly changed
    so that the entry points of ECLS's own library do not conflict with
    user defined entry points.

* Visible changes and ANSI compatibility:

  - The value of *package* is correctly set and restored while loading
    compiled code. This way, 'ecls -eval "(print *package*)"' produces
    the expected result #<"COMMON-LISP-USER" package>

  - COMPILE-FILE now outputs three values.

  - The value of si::*keep-definitions* determines whether the
    interpreter keeps the source of defined functions, for later use
    with COMPILE and DISASSEMBLE. For instance,
	> (set si::*keep-definitions* t)
	> (defun foo (x) (1+ x))
	> (compile 'foo)
	> (foo 2)
	3
	> (compile 'foo)
	;;; Error ....
    These definitions are lost once the function is compiled, hence
    the second error message.

  - Reader macro '#,' has been dropped. LOAD-TIME-VALUE added to both
    the interpreter and the compiler.

  - New, undocumented implementation of documentation strings which
    uses hash tables instead of property lists. The global variable
    si::*keep-documentation* determines whether documentation strings
    are stored in memory. It is possible to dump documentation strings
    to a help file.

  - New interface for building standalone programs and libraries, based
    on the functions C:BUILD-ECLS, C:BUILD-STATIC-LIBRARY and
    C:BUILD-SHARED-LIBRARY, all of which accept similar parameters,
    :PROLOGUE-CODE, :EPILOGE-CODE, :LISP-FILES, and :LD-FLAGS. Exhaustive
    documentation with examples included in the Developer's Guide.

  - Symbolic's update of the MIT LOOP macro imported.

  - A LET/LET* form in which the initializers for a variable have not
    the expected type produce a warning, but the code is accepted. For
    instance (LET (V) (DECLARE (TYPE FIXNUM V)) (SETQ V 1)) now
    compiles.

  - (SETF name), where name is a symbol, is now a valid function name in all
    contexts. It is accepted by DEFUN, FUNCTION, FBOUNDP, FMAKUNBOUND, etc,
    and it can be the on the function position in any form.

  - New specialized arrays for (UNSIGNED-BYTE 8) and (SIGNED-BYTE 8).
